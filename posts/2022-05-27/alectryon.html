<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ssreflect ssrbool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">is_bijection</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">to</span> : A -&gt; B) (<span class="nv">from</span> : B -&gt; A) : <span class="kt">Prop</span> :=
  { from_to : <span class="kr">forall</span> <span class="nv">a</span>, <span class="kn">from</span> (to a) = a
  ; to_from : <span class="kr">forall</span> <span class="nv">b</span>, to (<span class="kn">from</span> b) = b }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">bijection</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  { bij_to : A -&gt; B
  ; bij_from : B -&gt; A
  ; bij_is_bijection :&gt; is_bijection bij_to bij_from }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;&lt;--&gt;&quot;</span> := bijection (<span class="kn">at level</span> <span class="mi">90</span>) : type_scope.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk0"><span class="kn">Definition</span> <span class="nf">bijection_refl</span> {<span class="nv">A</span>} : A &lt;--&gt; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;--&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1"><span class="kn">Definition</span> <span class="nf">bijection_sym</span> {<span class="nv">A</span> <span class="nv">B</span>} : (A &lt;--&gt; B) -&gt; (B &lt;--&gt; A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;--&gt; B -&gt; B &lt;--&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2"><span class="kn">Definition</span> <span class="nf">bijection_trans</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} : (A &lt;--&gt; B) -&gt; (B &lt;--&gt; C) -&gt; (A &lt;--&gt; C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;--&gt; B -&gt; B &lt;--&gt; C -&gt; A &lt;--&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;&gt;&gt;&gt;&quot;</span> := bijection_trans (<span class="kn">at level</span> <span class="mi">40</span>).</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fin</span> (<span class="nv">n</span> : nat) : <span class="kt">Type</span> := { p | p &lt; n }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">fin&#39;</span> : nat -&gt; <span class="kt">Type</span> :=
| F0 : fin&#39; <span class="mi">1</span>
| FS : <span class="kr">forall</span> <span class="nv">n</span>, fin&#39; n -&gt; fin&#39; (S n).</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3"><span class="kn">Definition</span> <span class="nf">bijection_bool</span> : bool &lt;--&gt; fin <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">bool &lt;--&gt; fin <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk4"><span class="kn">Definition</span> <span class="nf">bijection_unit</span> : unit &lt;--&gt; fin <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">unit &lt;--&gt; fin <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk5"><span class="kn">Definition</span> <span class="nf">bijection_Empty_set</span> : Empty_set &lt;--&gt; fin <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty_set &lt;--&gt; fin <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">is_finite</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  { card : nat
  ; enum : A &lt;--&gt; fin card }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">finite_type</span> : <span class="kt">Type</span> :=
  { ft_type :&gt; <span class="kt">Type</span>
  ; ft_is_finite :&gt; is_finite ft_type }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;#|&#39; A &#39;|&#39;&quot;</span> := (card A).</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> fintype_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> fintype_scope <span class="kr">with</span> fintype.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Bind Scope</span> fintype_scope <span class="kr">with</span> finite_type.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6"><span class="kn">Theorem</span> <span class="nf">card_unique</span> {<span class="nv">A</span>} (<span class="nv">F1</span> <span class="nv">F2</span> : is_finite A) : card F1 = card F2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>F1, F2</var><span class="hyp-type"><b>: </b><span>is_finite A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| F1 | = #| F2 |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Intermediate exercise *)</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk7"><span class="kn">Theorem</span> <span class="nf">card_bijection</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">FA</span> : is_finite A) (<span class="nv">FB</span> : is_finite B)
  : (A &lt;--&gt; B) -&gt; card FA = card FB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>FA</var><span class="hyp-type"><b>: </b><span>is_finite A</span></span></span><br><span><var>FB</var><span class="hyp-type"><b>: </b><span>is_finite B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;--&gt; B -&gt; #| FA | = #| FB |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Like card_unique *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk8"><span class="kn">Theorem</span> <span class="nf">card_bijection_finite_type</span> {<span class="nv">A</span> <span class="nv">B</span> : finite_type}
  : (A &lt;--&gt; B) -&gt; #|A| = #|B|.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>finite_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;--&gt; B -&gt; #| A | = #| B |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>finite_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;--&gt; B -&gt; #| A | = #| B |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> card_bijection.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chka"><span class="kn">Theorem</span> <span class="nf">bijection_card</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">FA</span> : is_finite A) (<span class="nv">FB</span> : is_finite B)
  : card FA = card FB -&gt; (A &lt;--&gt; B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>FA</var><span class="hyp-type"><b>: </b><span>is_finite A</span></span></span><br><span><var>FB</var><span class="hyp-type"><b>: </b><span>is_finite B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| FA | = #| FB | -&gt; A &lt;--&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkb"><span class="kn">Theorem</span> <span class="nf">bijection_card_finite_type</span> {<span class="nv">A</span> <span class="nv">B</span> : finite_type}
  : #|A| = #|B| -&gt; (A &lt;--&gt; B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>finite_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| A | = #| B | -&gt; A &lt;--&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>finite_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| A | = #| B | -&gt; A &lt;--&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> bijection_card.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkd"><span class="kn">Definition</span> <span class="nf">bijection_sum_fin</span> {<span class="nv">n</span> <span class="nv">m</span>} : fin n + fin m &lt;--&gt; fin (n + m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin n + fin m &lt;--&gt; fin (n + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Intermediate exercise *)</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chke"><span class="kn">Definition</span> <span class="nf">bijection_sum</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span>}
  : (A &lt;--&gt; B) -&gt; (A&#39; &lt;--&gt; B&#39;) -&gt; (A + A&#39; &lt;--&gt; B + B&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;--&gt; B -&gt; A&#39; &lt;--&gt; B&#39; -&gt; A + A&#39; &lt;--&gt; B + B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_finite_sum</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">FA</span> : is_finite A) (<span class="nv">FB</span> : is_finite B)
  : is_finite (A + B) :=
  {| card := #|FA| + #|FB|
  ;  enum := bijection_sum (enum FA) (enum FB) &gt;&gt;&gt; bijection_sum_fin |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">finite_sum</span> (<span class="nv">A</span> <span class="nv">B</span> : finite_type) : finite_type :=
  {| ft_type := A + B ; ft_is_finite := is_finite_sum A B |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;+&quot;</span> := finite_sum : fintype_scope.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkf"><span class="kn">Theorem</span> <span class="nf">card_sum</span> {<span class="nv">A</span> <span class="nv">B</span> : finite_type} : #|(A + B)%fintype| = #|A| + #|B|.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>finite_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| (A + B)%fintype | = #| A | + #| B |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>finite_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| (A + B)%fintype | = #| A | + #| B |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk11"><span class="kn">Definition</span> <span class="nf">bijection_prod_fin</span> {<span class="nv">n</span> <span class="nv">m</span>} : fin n * fin m &lt;--&gt; fin (n * m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin n * fin m &lt;--&gt; fin (n * m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Intermediate exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk12"><span class="kn">Definition</span> <span class="nf">bijection_prod</span> {<span class="nv">A</span> <span class="nv">A&#39;</span> <span class="nv">B</span> <span class="nv">B&#39;</span>}
  : (A &lt;--&gt; B) -&gt; (A&#39; &lt;--&gt; B&#39;) -&gt; (A * A&#39; &lt;--&gt; B * B&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A', B, B'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;--&gt; B -&gt; A&#39; &lt;--&gt; B&#39; -&gt; A * A&#39; &lt;--&gt; B * B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_finite_prod</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">FA</span> : is_finite A) (<span class="nv">FB</span> : is_finite B)
  : is_finite (A * B) :=
  {| card := #|FA| * #|FB|
  ;  enum := bijection_prod (enum FA) (enum FB) &gt;&gt;&gt; bijection_prod_fin |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">finite_prod</span> (<span class="nv">A</span> <span class="nv">B</span> : finite_type) : finite_type :=
  {| ft_type := A * B ; ft_is_finite := is_finite_prod A B |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;*&quot;</span> := finite_prod : fintype_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk13"><span class="kn">Theorem</span> <span class="nf">card_prod</span> {<span class="nv">A</span> <span class="nv">B</span> : finite_type} : #|(A * B)%fintype| = #|A| * #|B|.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>finite_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| (A * B)%fintype | = #| A | * #| B |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>finite_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| (A * B)%fintype | = #| A | * #| B |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">set_of</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := (A -&gt; bool).</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Operations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> : <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">union&#39;</span> (<span class="nv">X</span> <span class="nv">Y</span> : set_of A) : set_of A := <span class="kr">fun</span> <span class="nv">a</span> =&gt; X a || Y a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">intersection&#39;</span> (<span class="nv">X</span> <span class="nv">Y</span> : set_of A) : set_of A := <span class="kr">fun</span> <span class="nv">a</span> =&gt; X a &amp;&amp; Y a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">complement&#39;</span> (<span class="nv">X</span> : set_of A) : set_of A := <span class="kr">fun</span> <span class="nv">a</span> =&gt; negb (X a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Operations</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> set_of_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> set_of_scope <span class="kr">with</span> set_of.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Bind Scope</span> set_of_scope <span class="kr">with</span> set_of.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;∪&quot;</span> := union&#39; (<span class="kn">at level</span> <span class="mi">40</span>) : set_of_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;∩&quot;</span> := intersection&#39; (<span class="kn">at level</span> <span class="mi">40</span>) : set_of_scope.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">to_type</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">X</span> : set_of A) : <span class="kt">Type</span> := { a : A | X a }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">to_type</span> : set_of &gt;-&gt; <span class="kt">Sortclass</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">finite_set_of</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  { elem_of :&gt; set_of A
  ; fso_is_finite :&gt; is_finite (to_type elem_of)
  }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">to_finite_type</span> {<span class="nv">A</span>} (<span class="nv">X</span> : finite_set_of A) : finite_type :=
  {| ft_type := elem_of X
  ;  ft_is_finite := X |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">to_finite_type</span> : finite_set_of &gt;-&gt; finite_type.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">is_section</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">to</span> : A -&gt; B) (<span class="nv">from</span> : B -&gt; A) : <span class="kt">Prop</span> :=
  { s_from_to : <span class="kr">forall</span> <span class="nv">a</span>, <span class="kn">from</span> (to a) = a }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">section</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  { s_from : A -&gt; B
  ; s_to : B -&gt; A
  ; s_is_section : is_section s_from s_to }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk15"><span class="kn">Definition</span> <span class="nf">section_bijection</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat)
  : section A (fin n) -&gt; { m &amp; A &lt;--&gt; fin m }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section A (fin n) -&gt; {m : nat &amp; A &lt;--&gt; fin m}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Hard exercise *)</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk16"><span class="kn">Definition</span> <span class="nf">section_union</span> {<span class="nv">A</span>} (<span class="nv">X</span> <span class="nv">Y</span> : set_of A)
  : section (X ∪ Y)%set_of (X + Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∪ Y)%set_of (X + Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk17"><span class="kn">Definition</span> <span class="nf">section_intersection</span> {<span class="nv">A</span>} (<span class="nv">X</span> <span class="nv">Y</span> : set_of A)
  : section (X ∩ Y)%set_of X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∩ Y)%set_of X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk18"><span class="kn">Theorem</span> <span class="nf">section_extend</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>)
  : section A B -&gt; (B &lt;--&gt; C) -&gt; section A C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section A B -&gt; B &lt;--&gt; C -&gt; section A C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Easy exercise *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk19"><span class="kn">Definition</span> <span class="nf">section_union&#39;</span> {<span class="nv">A</span>} (<span class="nv">X</span> <span class="nv">Y</span> : finite_set_of A)
  : section (X ∪ Y)%set_of (fin (#|X| + #|Y|)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∪ Y)%set_of (fin (#| X | + #| Y |))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∪ Y)%set_of (fin (#| X | + #| Y |))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1b"><span class="nb">eapply</span> section_extend.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∪ Y)%set_of <span class="nl">?B</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><label class="goal-separator" for="stdin-chk1c"><hr></label><div class="goal-conclusion"><span class="nl">?B</span> &lt;--&gt; fin (#| X | + #| Y |)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∪ Y)%set_of <span class="nl">?B</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> section_union.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X + Y &lt;--&gt; fin (#| X | + #| Y |)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> is_finite_sum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1f"><span class="kn">Definition</span> <span class="nf">section_intersection&#39;</span> {<span class="nv">A</span>} (<span class="nv">X</span> <span class="nv">Y</span> : finite_set_of A)
  : section (X ∩ Y)%set_of (fin #|X|).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∩ Y)%set_of (fin #| X |)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∩ Y)%set_of (fin #| X |)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk21"><span class="nb">eapply</span> section_extend.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∩ Y)%set_of <span class="nl">?B</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><label class="goal-separator" for="stdin-chk22"><hr></label><div class="goal-conclusion"><span class="nl">?B</span> &lt;--&gt; fin #| X |</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk23">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∩ Y)%set_of <span class="nl">?B</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> section_intersection.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk24">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X &lt;--&gt; fin #| X |</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> enum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk25"><span class="kn">Theorem</span> <span class="nf">is_finite_union</span> {<span class="nv">A</span>} {<span class="nv">X</span> <span class="nv">Y</span> : set_of A}
    (<span class="nv">FX</span> : is_finite X) (<span class="nv">FY</span> : is_finite Y)
  : is_finite (X ∪ Y)%set_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_finite (X ∪ Y)%set_of</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_finite (X ∪ Y)%set_of</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk27"><span class="nb">refine</span> {| enum := projT2 (section_bijection _) |}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∪ Y)%set_of (fin <span class="nl">?Goal</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk28"><span class="nb">eapply</span> (section_extend (B := X + Y)%type).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∪ Y)%set_of (X + Y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><label class="goal-separator" for="stdin-chk29"><hr></label><div class="goal-conclusion">X + Y &lt;--&gt; fin <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∪ Y)%set_of (X + Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> section_union.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X + Y &lt;--&gt; fin <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (is_finite_sum FX FY).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2c"><span class="kn">Theorem</span> <span class="nf">is_finite_intersection</span> {<span class="nv">A</span>} {<span class="nv">X</span> <span class="nv">Y</span> : set_of A}
    (<span class="nv">FX</span> : is_finite X) (<span class="nv">FY</span> : is_finite Y)
  : is_finite (X ∩ Y)%set_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_finite (X ∩ Y)%set_of</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_finite (X ∩ Y)%set_of</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2e"><span class="nb">refine</span> {| enum := projT2 (section_bijection _) |}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∩ Y)%set_of (fin <span class="nl">?Goal</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2f"><span class="nb">eapply</span> section_extend.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∩ Y)%set_of <span class="nl">?B</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><label class="goal-separator" for="stdin-chk30"><hr></label><div class="goal-conclusion"><span class="nl">?B</span> &lt;--&gt; fin <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">section (X ∩ Y)%set_of <span class="nl">?B</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> section_intersection.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk32">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>set_of A</span></span></span><br><span><var>FX</var><span class="hyp-type"><b>: </b><span>is_finite X</span></span></span><br><span><var>FY</var><span class="hyp-type"><b>: </b><span>is_finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X &lt;--&gt; fin <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (enum FX).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">union</span> {<span class="nv">A</span>} (<span class="nv">X</span> <span class="nv">Y</span> : finite_set_of A) : finite_set_of A :=
  {| fso_is_finite := is_finite_union X Y |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">intersection</span> {<span class="nv">A</span>} (<span class="nv">X</span> <span class="nv">Y</span> : finite_set_of A) : finite_set_of A :=
  {| fso_is_finite := is_finite_intersection X Y |}.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> fso_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> fso_scope <span class="kr">with</span> fso.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Bind Scope</span> fso_scope <span class="kr">with</span> finite_set_of.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;∪&quot;</span> := union (<span class="kn">at level</span> <span class="mi">40</span>) : fso_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;∩&quot;</span> := intersection (<span class="kn">at level</span> <span class="mi">40</span>) : fso_scope.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Open Scope</span> fso_scope.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk33"><span class="kn">Definition</span> <span class="nf">inclusion_exclusion_bijection</span> {<span class="nv">A</span>} (<span class="nv">X</span> <span class="nv">Y</span> : finite_set_of A)
  : (X ∪ Y)%set_of + (X ∩ Y)%set_of &lt;--&gt; X + Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X ∪ Y)%set_of + (X ∩ Y)%set_of &lt;--&gt; X + Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>. <span class="c">(* Hard exercise *)</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk34"><span class="kn">Theorem</span> <span class="nf">inclusion_exclusion</span> {<span class="nv">A</span>} (<span class="nv">X</span> <span class="nv">Y</span> : finite_set_of A)
  : #|X ∪ Y| + #|X ∩ Y| = #|X| + #|Y|.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| X ∪ Y | + #| X ∩ Y | = #| X | + #| Y |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#| X ∪ Y | + #| X ∩ Y | = #| X | + #| Y |</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk36"><span class="nb">apply</span> (@card_bijection_finite_type ((X ∪ Y) + (X ∩ Y)) (X + Y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>finite_set_of A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X ∪ Y + X ∩ Y)%fintype &lt;--&gt; (X + Y)%fintype</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> inclusion_exclusion_bijection.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
