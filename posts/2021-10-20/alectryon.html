<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Morphisms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Contextual Implicit</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Free</span> (<span class="nv">f</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">a</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
| Pure : a -&gt; Free f a
| Bind : <span class="kr">forall</span> <span class="nv">e</span>, f e -&gt; (e -&gt; Free f a) -&gt; Free f a
.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Monad</span> (<span class="nv">m</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  { pure : <span class="kr">forall</span> {<span class="nv">a</span>}, a -&gt; m a
  ; bind : <span class="kr">forall</span> {<span class="nv">a</span> <span class="nv">b</span>}, m a -&gt; (a -&gt; m b) -&gt; m b
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* The braces after `forall` make the arguments implicit. *)</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">MonadFree</span> {<span class="nv">f</span> <span class="nv">m</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>} `{Monad m} : <span class="kt">Type</span> :=
  { free : <span class="kr">forall</span> {<span class="nv">x</span>}, f x -&gt; m x }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Some more implicit arguments nonsense. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> MonadFree f m {_}.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Free&#39;</span> (<span class="nv">f</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) (<span class="nv">a</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  <span class="kr">forall</span> <span class="nv">m</span> `(MonadFree f m), m a.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bindFree</span> {<span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">u</span> : Free f a) (<span class="nv">k</span> : a -&gt; Free f b) : Free f b :=
  <span class="kr">match</span> u <span class="kr">with</span>
  | Pure a =&gt; k a
  | Bind e h =&gt; Bind e (<span class="kr">fun</span> <span class="nv">x</span> =&gt; bindFree (h x) k)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk0"><span class="kn">Instance</span> <span class="nf">Monad_Free</span> <span class="nv">f</span> : Monad (Free f) :=
  {| pure := @Pure f
  ;  bind := @bindFree f
  |}.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> instance locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding instances <span class="kn">outside</span> of sections without
specifying an explicit locality attribute <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible. Use the attributes #[local], #[<span class="kn">global</span>] <span class="kn">and</span>
#[export] depending on your choice. For example:
<span class="s2">&quot;#[export] Instance Foo : Bar := baz.&quot;</span>
[deprecated-instance-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1"><span class="kn">Instance</span> <span class="nf">MonadFree_Free</span> <span class="nv">f</span> : MonadFree f (Free f) :=
  {| free A e := Bind e (<span class="kr">fun</span> <span class="nv">a</span> =&gt; Pure a)
  |}.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> instance locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding instances <span class="kn">outside</span> of sections without
specifying an explicit locality attribute <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible. Use the attributes #[local], #[<span class="kn">global</span>] <span class="kn">and</span>
#[export] depending on your choice. For example:
<span class="s2">&quot;#[export] Instance Foo : Bar := baz.&quot;</span>
[deprecated-instance-without-locality,deprecated]</blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fromFree&#39;</span> {<span class="nv">f</span> <span class="nv">a</span>} : Free&#39; f a -&gt; Free f a :=
  <span class="kr">fun</span> <span class="nv">u</span> =&gt; u (Free f) _ _.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">foldFree</span> {<span class="nv">f</span> <span class="nv">m</span> <span class="nv">a</span>} `{MonadFree f m} (u : Free f a) : m a :=
  <span class="kr">match</span> u <span class="kr">with</span>
  | Pure a =&gt; pure a
  | Bind e k =&gt; bind (free e) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; foldFree (k x))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">toFree&#39;</span> {<span class="nv">f</span> <span class="nv">a</span>} : Free f a -&gt; Free&#39; f a :=
  <span class="kr">fun</span> <span class="nv">u</span> <span class="nv">M</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; foldFree u.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">PropEq</span> (<span class="nv">a</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  propeq : a -&gt; a -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2"><span class="kn">Notation</span> <span class="s2">&quot;x = y&quot;</span> := (propeq x y) : type_scope.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ = _&quot;</span> was already used <span class="kr">in</span> scope type_scope.
[notation-overridden,parsing]</blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">eq_Free</span> <span class="nv">f</span> <span class="nv">a</span> : PropEq (Free f a) :=
| eq_Free_Pure x : eq_Free (Pure x) (Pure x)
| eq_Free_Bind p (e : f p) k1 k2
  : (<span class="kr">forall</span> <span class="nv">x</span>, eq_Free (k1 x) (k2 x)) -&gt;
    eq_Free (Bind e k1) (Bind e k2)
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Register it as an instance of PropEq *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3"><span class="kn">Existing Instance</span> <span class="nf">eq_Free</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> instance locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding instances <span class="kn">outside</span> of sections without
specifying an explicit locality attribute <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible. Use the attributes #[local], #[<span class="kn">global</span>] <span class="kn">and</span>
#[export] depending on your choice. For example:
<span class="s2">&quot;#[export] Instance Foo : Bar := baz.&quot;</span>
[deprecated-instance-without-locality,deprecated]</blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk4"><span class="kn">Theorem</span> <span class="nf">to_from</span> <span class="nv">f</span> <span class="nv">a</span> (<span class="nv">u</span> : Free f a)
  : fromFree&#39; (toFree&#39; u) = u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free f a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fromFree&#39; (toFree&#39; u) = u</div></blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free f a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fromFree&#39; (toFree&#39; u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6"><span class="nb">induction</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fromFree&#39; (toFree&#39; (Pure a0)) = Pure a0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a, e</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f e</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>e -&gt; Free f a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> : e, fromFree&#39; (toFree&#39; (f1 e)) = f1 e</span></span></span><br></div><label class="goal-separator" for="stdin-chk7"><hr></label><div class="goal-conclusion">fromFree&#39; (toFree&#39; (Bind f0 f1)) = Bind f0 f1</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk8"><span class="kp">all</span>: <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pure a0 = Pure a0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a, e</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f e</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>e -&gt; Free f a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> : e, fromFree&#39; (toFree&#39; (f1 e)) = f1 e</span></span></span><br></div><label class="goal-separator" for="stdin-chk9"><hr></label><div class="goal-conclusion">Bind f0 (<span class="kr">fun</span> <span class="nv">x</span> : e =&gt; foldFree (f1 x)) = Bind f0 f1</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* u1 and u2 are &quot;equal&quot; when all of their specializations</span>
<span class="c">   (u1 m _ _) and (u2 m _ _) are equal. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eq_Free&#39;_very_naive</span> <span class="nv">f</span> <span class="nv">a</span> (<span class="nv">u1</span> <span class="nv">u2</span> : Free&#39; f a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">m</span> `(MonadFree f m) `(<span class="kr">forall</span> <span class="nv">x</span>, PropEq (m x)),
    u1 m _ _ = u2 m _ _.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">LawfulMonad</span> {<span class="nv">m</span>} `{Monad m} `{<span class="kr">forall</span> <span class="nv">a</span>, PropEq (m a)} : <span class="kt">Prop</span> :=
  { Equivalence_LawfulMonad :&gt; <span class="kr">forall</span> <span class="nv">a</span>, Equivalence (propeq (a := m a))
  ; propeq_bind : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> (<span class="nv">u</span> <span class="nv">u&#39;</span> : m a) (<span class="nv">k</span> <span class="nv">k&#39;</span> : a -&gt; m b),
      u = u&#39; -&gt; (<span class="kr">forall</span> <span class="nv">x</span>, k x = k&#39; x) -&gt; bind u k = bind u&#39; k&#39;
  ; bind_pure : <span class="kr">forall</span> <span class="nv">a</span> (<span class="nv">u</span> : m a),
      bind u (pure (a := a)) = u
  ; pure_bind : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> (<span class="nv">x</span> : a) (<span class="nv">k</span> : a -&gt; m b),
      bind (pure x) k = k x
  ; bind_bind : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> (<span class="nv">u</span> : m a) (<span class="nv">k</span> : a -&gt; m b) (<span class="nv">h</span> : b -&gt; m c),
      bind (bind u k) h = bind u (<span class="kr">fun</span> <span class="nv">x</span> =&gt; bind (k x) h)
  }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eq_Free&#39;_naive</span> <span class="nv">f</span> <span class="nv">a</span> (<span class="nv">u1</span> <span class="nv">u2</span> : Free&#39; f a) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">m</span> `(MonadFree f m) `(<span class="kr">forall</span> <span class="nv">x</span>, PropEq (m x)) `(!LawfulMonad (m := m)),
    u1 m _ _ = u2 m _ _.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">RFree</span> {<span class="nv">f₁</span> <span class="nv">f₂</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>}
    (<span class="nv">Rf</span> : <span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>, (a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; f₁ a₁ -&gt; f₂ a₂ -&gt; <span class="kt">Prop</span>)
    {<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>} (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) : Free f₁ a₁ -&gt; Free f₂ a₂ -&gt; <span class="kt">Prop</span> :=
  | RFree_Pure : <span class="kr">forall</span> (<span class="nv">x₁</span> : a₁) (<span class="nv">x₂</span> : a₂),
      Ra x₁ x₂ -&gt; RFree Rf Ra (Pure x₁) (Pure x₂)
  | RFree_Bind : <span class="kr">forall</span> (<span class="nv">e₁</span> <span class="nv">e₂</span> : <span class="kt">Type</span>) (<span class="nv">Re</span> : e₁ -&gt; e₂ -&gt; <span class="kt">Prop</span>) (<span class="nv">y₁</span> : f₁ e₁) (<span class="nv">y₂</span> : f₂ e₂),
      Rf e₁ e₂ Re y₁ y₂ -&gt;
      <span class="kr">forall</span> (<span class="nv">k₁</span> : e₁ -&gt; Free f₁ a₁) (<span class="nv">k₂</span> : e₂ -&gt; Free f₂ a₂),
      (<span class="kr">forall</span> (<span class="nv">x₁</span> : e₁) (<span class="nv">x₂</span> : e₂),
        Re x₁ x₂ -&gt; RFree Rf Ra (k₁ x₁) (k₂ x₂)) -&gt;
      RFree Rf Ra (Bind y₁ k₁) (Bind y₂ k₂).</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chka"><span class="kn">Definition</span> <span class="nf">inv_RFree</span> {<span class="nv">f₁</span> <span class="nv">f₂</span>} <span class="nv">Rf</span> {<span class="nv">a₁</span> <span class="nv">a₂</span>} <span class="nv">Ra</span> (<span class="nv">u₁</span> : Free f₁ a₁) (<span class="nv">u₂</span> : Free f₂ a₂)
  : RFree Rf Ra u₁ u₂ -&gt;
    <span class="kr">match</span> u₁, u₂ <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
    | Pure a₁, Pure a₂ =&gt; Ra a₁ a₂
    | Bind y₁ k₁, Bind y₂ k₂ =&gt;
      <span class="kr">exists</span> <span class="nv">Re</span>, Rf _ _ Re y₁ y₂ /\
        (<span class="kr">forall</span> <span class="nv">x₁</span> <span class="nv">x₂</span>, Re x₁ x₂ -&gt; RFree Rf Ra (k₁ x₁) (k₂ x₂))
    | _, _ =&gt; <span class="kt">False</span>
    <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f₁, f₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; f₁ a₁ -&gt; f₂ a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁</var><span class="hyp-type"><b>: </b><span>Free f₁ a₁</span></span></span><br><span><var>u₂</var><span class="hyp-type"><b>: </b><span>Free f₂ a₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RFree Rf Ra u₁ u₂ -&gt;
<span class="kr">match</span> u₁ <span class="kr">with</span>
| Pure a₁ =&gt;
    <span class="kr">match</span> u₂ <span class="kr">with</span>
    | Pure a₂ =&gt; Ra a₁ a₂
    | Bind _ _ =&gt; <span class="kt">False</span>
    <span class="kr">end</span>
| @Bind _ _ e y₁ k₁ =&gt;
    <span class="kr">match</span> u₂ <span class="kr">with</span>
    | Pure _ =&gt; <span class="kt">False</span>
    | @Bind _ _ e0 y₂ k₂ =&gt;
        <span class="kr">exists</span> <span class="nv">Re</span> : e -&gt; e0 -&gt; <span class="kt">Prop</span>,
          Rf e e0 Re y₁ y₂ /\
          (<span class="kr">forall</span> (<span class="nv">x₁</span> : e) (<span class="nv">x₂</span> : e0),
           Re x₁ x₂ -&gt; RFree Rf Ra (k₁ x₁) (k₂ x₂))
    <span class="kr">end</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f₁, f₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; f₁ a₁ -&gt; f₂ a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁</var><span class="hyp-type"><b>: </b><span>Free f₁ a₁</span></span></span><br><span><var>u₂</var><span class="hyp-type"><b>: </b><span>Free f₂ a₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RFree Rf Ra u₁ u₂ -&gt;
<span class="kr">match</span> u₁ <span class="kr">with</span>
| Pure a₁ =&gt;
    <span class="kr">match</span> u₂ <span class="kr">with</span>
    | Pure a₂ =&gt; Ra a₁ a₂
    | Bind _ _ =&gt; <span class="kt">False</span>
    <span class="kr">end</span>
| @Bind _ _ e y₁ k₁ =&gt;
    <span class="kr">match</span> u₂ <span class="kr">with</span>
    | Pure _ =&gt; <span class="kt">False</span>
    | @Bind _ _ e0 y₂ k₂ =&gt;
        <span class="kr">exists</span> <span class="nv">Re</span> : e -&gt; e0 -&gt; <span class="kt">Prop</span>,
          Rf e e0 Re y₁ y₂ /\
          (<span class="kr">forall</span> (<span class="nv">x₁</span> : e) (<span class="nv">x₂</span> : e0),
           Re x₁ x₂ -&gt; RFree Rf Ra (k₁ x₁) (k₂ x₂))
    <span class="kr">end</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">RMonad</span> (<span class="nv">m₁</span> <span class="nv">m₂</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">Rm</span> : <span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>, (a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; m₁ a₁ -&gt; m₂ a₂ -&gt; <span class="kt">Prop</span>)
    `{Monad m₁} `{Monad m₂} : <span class="kt">Prop</span> :=
  { RMonad_pure : <span class="kr">forall</span> (<span class="nv">t₁</span> <span class="nv">t₂</span> : <span class="kt">Type</span>) (<span class="nv">Rt</span> : t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span>) (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
      Rt x₁ x₂ -&gt; Rm t₁ t₂ Rt (pure x₁) (pure x₂)
  ; RMonad_bind : <span class="kr">forall</span> (<span class="nv">t₁</span> <span class="nv">t₂</span> : <span class="kt">Type</span>) (<span class="nv">Rt</span> : t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span>) 
      (<span class="nv">u₁</span> <span class="nv">u₂</span> : <span class="kt">Type</span>) (<span class="nv">Ru</span> : u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span>) (<span class="nv">x₁</span> : m₁ t₁) (<span class="nv">x₂</span> : m₂ t₂),
      Rm t₁ t₂ Rt x₁ x₂ -&gt;
      <span class="kr">forall</span> (<span class="nv">k₁</span> : t₁ -&gt; m₁ u₁) (<span class="nv">k₂</span> : t₂ -&gt; m₂ u₂),
      (<span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
         Rt x₁ x₂ -&gt; Rm u₁ u₂ Ru (k₁ x₁) (k₂ x₂)) -&gt;
      Rm u₁ u₂ Ru (bind x₁ k₁) (bind x₂ k₂)
  }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">RMonadFree</span> (<span class="nv">f₁</span> <span class="nv">f₂</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">Rf</span> : <span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>, (a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; f₁ a₁ -&gt; f₂ a₂ -&gt; <span class="kt">Prop</span>)
    (<span class="nv">m₁</span> <span class="nv">m₂</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>)
    (<span class="nv">Rm</span> : <span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>, (a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; m₁ a₁ -&gt; m₂ a₂ -&gt; <span class="kt">Prop</span>)
    `{MonadFree f₁ m₁} `{MonadFree f₂ m₂} : <span class="kt">Prop</span> :=
  { RMonadFree_free : <span class="kr">forall</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) (<span class="nv">x₁</span> : f₁ a₁) (<span class="nv">x₂</span> : f₂ a₂),
      Rf a₁ a₂ Ra x₁ x₂ -&gt; Rm a₁ a₂ Ra (free x₁) (free x₂)
  }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RFree&#39;</span> {<span class="nv">f₁</span> <span class="nv">f₂</span>} <span class="nv">Rf</span> {<span class="nv">a₁</span> <span class="nv">a₂</span>} <span class="nv">Ra</span> (<span class="nv">u₁</span> : Free&#39; f₁ a₁) (<span class="nv">u₂</span> : Free&#39; f₂ a₂) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">m₁</span> <span class="nv">m₂</span> `(MonadFree f₁ m₁) `(MonadFree f₂ m₂) Rm
    (pm : RMonad Rm) (pf : RMonadFree Rf Rm),
    Rm _ _ Ra (u₁ m₁ _ _) (u₂ m₂ _ _).</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">PropEq1</span> (<span class="nv">m</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  propeq1 : <span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span>, (a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; m a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkc"><span class="kn">Instance</span> <span class="nf">PropEq_PropEq1</span> {<span class="nv">m</span>} `{PropEq1 m} {a} : PropEq (m a) := propeq1 eq.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> instance locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding instances <span class="kn">outside</span> of sections without
specifying an explicit locality attribute <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible. Use the attributes #[local], #[<span class="kn">global</span>] <span class="kn">and</span>
#[export] depending on your choice. For example:
<span class="s2">&quot;#[export] Instance Foo : Bar := baz.&quot;</span>
[deprecated-instance-without-locality,deprecated]</blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Trans_PropEq1</span> {<span class="nv">m</span>} `{PropEq1 m} : <span class="kt">Prop</span> :=
  trans_propeq1 : <span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> (<span class="nv">r</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) <span class="nv">x₁</span> <span class="nv">x₁&#39;</span> <span class="nv">x₂</span> <span class="nv">x₂&#39;</span>,
    x₁ = x₁&#39; -&gt; propeq1 r x₁&#39; x₂ -&gt; x₂ = x₂&#39; -&gt; propeq1 r x₁ x₂&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ReallyLawfulMonad</span> <span class="nv">m</span> `{Monad m} `{PropEq1 m} : <span class="kt">Prop</span> :=
  { LawfulMonad_RLM :&gt; LawfulMonad (m := m)
  ; Trans_PropEq1_RLM :&gt; Trans_PropEq1 (m := m)
  ; RMonad_RLM : RMonad (propeq1 (m := m))
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ReallyLawfulMonadFree</span> <span class="nv">f</span> `{PropEq1 f} m `{MonadFree f m} `{PropEq1 m} : <span class="kt">Prop</span> :=
  { ReallyLawfulMonad_RLMF :&gt; ReallyLawfulMonad (m := m)
  ; RMonadFree_RLMF : RMonadFree (propeq1 (m := f)) (propeq1 (m := m))
  }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkd"><span class="kn">Instance</span> <span class="nf">eq_Free&#39;</span> <span class="nv">f</span> `(PropEq1 f) a : PropEq (Free&#39; f a) :=
  <span class="kr">fun</span> <span class="nv">u₁</span> <span class="nv">u₂</span> =&gt;
    <span class="kr">forall</span> <span class="nv">m</span> `(MonadFree f m) `(PropEq1 m) `(!ReallyLawfulMonadFree (m := m)),
      u₁ m _ _ = u₂ m _ _.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> instance locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding instances <span class="kn">outside</span> of sections without
specifying an explicit locality attribute <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible. Use the attributes #[local], #[<span class="kn">global</span>] <span class="kn">and</span>
#[export] depending on your choice. For example:
<span class="s2">&quot;#[export] Instance Foo : Bar := baz.&quot;</span>
[deprecated-instance-without-locality,deprecated]</blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chke"><span class="kn">Lemma</span> <span class="nf">foldFree_bindFree</span> {<span class="nv">f</span> <span class="nv">m</span>} `{MonadFree f m} `{<span class="kr">forall</span> <span class="nv">a</span>, PropEq (m a)} `{!LawfulMonad (m := m)}
    {a b} (u : Free f a) (k : a -&gt; Free f b)
  : foldFree (bindFree u k) = bind (foldFree u) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; foldFree (k x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free f a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (bindFree u k) =
bind (foldFree u) (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free f a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (bindFree u k) =
bind (foldFree u) (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk10"><span class="nb">induction</span> u; <span class="nb">cbn</span> [bindFree foldFree].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (k a0) =
bind (pure a0) (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b, e</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f e</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>e -&gt; Free f a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> : e,
foldFree (bindFree (f1 e) k) =
bind (foldFree (f1 e))
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</span></span></span><br></div><label class="goal-separator" for="stdin-chk11"><hr></label><div class="goal-conclusion">bind (free f0)
  (<span class="kr">fun</span> <span class="nv">x</span> : e =&gt; foldFree (bindFree (f1 x) k)) =
bind (bind (free f0) (<span class="kr">fun</span> <span class="nv">x</span> : e =&gt; foldFree (f1 x)))
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (k a0) =
bind (pure a0) (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk13"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind (pure a0) (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x)) =
foldFree (k a0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pure_bind <span class="kr">with</span> (k0 := <span class="kr">fun</span> <span class="nv">x</span> =&gt; foldFree (k x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk14">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b, e</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f e</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>e -&gt; Free f a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> : e,
foldFree (bindFree (f1 e) k) =
bind (foldFree (f1 e))
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind (free f0)
  (<span class="kr">fun</span> <span class="nv">x</span> : e =&gt; foldFree (bindFree (f1 x) k)) =
bind (bind (free f0) (<span class="kr">fun</span> <span class="nv">x</span> : e =&gt; foldFree (f1 x)))
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk15"><span class="nb">etransitivity</span>; [ | <span class="nb">symmetry</span>; <span class="nb">apply</span> bind_bind ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b, e</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f e</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>e -&gt; Free f a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> : e,
foldFree (bindFree (f1 e) k) =
bind (foldFree (f1 e))
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind (free f0)
  (<span class="kr">fun</span> <span class="nv">x</span> : e =&gt; foldFree (bindFree (f1 x) k)) =
bind (free f0)
  (<span class="kr">fun</span> <span class="nv">x</span> : e =&gt;
   bind ((<span class="kr">fun</span> <span class="nv">x0</span> : e =&gt; foldFree (f1 x0)) x)
     (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; foldFree (k x0)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk16"><span class="nb">eapply</span> propeq_bind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b, e</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f e</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>e -&gt; Free f a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> : e,
foldFree (bindFree (f1 e) k) =
bind (foldFree (f1 e))
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free f0 = free f0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b, e</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f e</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>e -&gt; Free f a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> : e,
foldFree (bindFree (f1 e) k) =
bind (foldFree (f1 e))
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</span></span></span><br></div><label class="goal-separator" for="stdin-chk17"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : e,
foldFree (bindFree (f1 x) k) =
bind (foldFree (f1 x)) (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; foldFree (k x0))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk18">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b, e</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f e</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>e -&gt; Free f a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> : e,
foldFree (bindFree (f1 e) k) =
bind (foldFree (f1 e))
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free f0 = free f0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk19">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, PropEq (m a)</span></span></span><br><span><var>LawfulMonad0</var><span class="hyp-type"><b>: </b><span>LawfulMonad</span></span></span><br><span><var>a, b, e</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f e</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>e -&gt; Free f a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>a -&gt; Free f b</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> : e,
foldFree (bindFree (f1 e) k) =
bind (foldFree (f1 e))
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; foldFree (k x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : e,
foldFree (bindFree (f1 x) k) =
bind (foldFree (f1 x)) (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; foldFree (k x0))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ISOPROOF</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">f</span> <span class="nv">m</span>} `{MonadFree f m} `{PropEq1 m} `{!ReallyLawfulMonad (m := m)}.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">R</span> := (<span class="kr">fun</span> <span class="nv">a₁</span> <span class="nv">a₂</span> (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) <span class="nv">u₁</span> <span class="nv">u₂</span> =&gt; propeq1 Ra (foldFree u₁) u₂).</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1a"><span class="kn">Lemma</span> <span class="nf">RMonad_foldFree</span> : RMonad (m₁ := Free f) R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RMonad R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RMonad R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1c"><span class="nb">constructor</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rt x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R Rt (pure x₁) (pure x₂)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁, u₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ru</var><span class="hyp-type"><b>: </b><span>u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>Free f t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>m t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R Rt x₁ x₂</span></span></span><br><span><var>k₁</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; Free f u₁</span></span></span><br><span><var>k₂</var><span class="hyp-type"><b>: </b><span>t₂ -&gt; m u₂</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
Rt x₁ x₂ -&gt; R Ru (k₁ x₁) (k₂ x₂)</span></span></span><br></div><label class="goal-separator" for="stdin-chk1d"><hr></label><div class="goal-conclusion">R Ru (bind x₁ k₁) (bind x₂ k₂)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rt x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R Rt (pure x₁) (pure x₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rt x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R Rt (Pure x₁) (pure x₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> RMonad_RLM; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁, u₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ru</var><span class="hyp-type"><b>: </b><span>u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>Free f t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>m t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R Rt x₁ x₂</span></span></span><br><span><var>k₁</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; Free f u₁</span></span></span><br><span><var>k₂</var><span class="hyp-type"><b>: </b><span>t₂ -&gt; m u₂</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
Rt x₁ x₂ -&gt; R Ru (k₁ x₁) (k₂ x₂)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R Ru (bind x₁ k₁) (bind x₂ k₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk21"><span class="nb">unfold</span> R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁, u₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ru</var><span class="hyp-type"><b>: </b><span>u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>Free f t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>m t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R Rt x₁ x₂</span></span></span><br><span><var>k₁</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; Free f u₁</span></span></span><br><span><var>k₂</var><span class="hyp-type"><b>: </b><span>t₂ -&gt; m u₂</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
Rt x₁ x₂ -&gt; R Ru (k₁ x₁) (k₂ x₂)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">propeq1 Ru (foldFree (bind x₁ k₁)) (bind x₂ k₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk22"><span class="nb">eapply</span> trans_propeq1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁, u₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ru</var><span class="hyp-type"><b>: </b><span>u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>Free f t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>m t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R Rt x₁ x₂</span></span></span><br><span><var>k₁</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; Free f u₁</span></span></span><br><span><var>k₂</var><span class="hyp-type"><b>: </b><span>t₂ -&gt; m u₂</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
Rt x₁ x₂ -&gt; R Ru (k₁ x₁) (k₂ x₂)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (bind x₁ k₁) = <span class="nl">?x₁&#39;</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁, u₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ru</var><span class="hyp-type"><b>: </b><span>u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>Free f t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>m t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R Rt x₁ x₂</span></span></span><br><span><var>k₁</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; Free f u₁</span></span></span><br><span><var>k₂</var><span class="hyp-type"><b>: </b><span>t₂ -&gt; m u₂</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
Rt x₁ x₂ -&gt; R Ru (k₁ x₁) (k₂ x₂)</span></span></span><br></div><label class="goal-separator" for="stdin-chk23"><hr></label><div class="goal-conclusion">propeq1 Ru <span class="nl">?x₁&#39;</span> <span class="nl">?x₂</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="stdin-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁, u₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ru</var><span class="hyp-type"><b>: </b><span>u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>Free f t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>m t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R Rt x₁ x₂</span></span></span><br><span><var>k₁</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; Free f u₁</span></span></span><br><span><var>k₂</var><span class="hyp-type"><b>: </b><span>t₂ -&gt; m u₂</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
Rt x₁ x₂ -&gt; R Ru (k₁ x₁) (k₂ x₂)</span></span></span><br></div><label class="goal-separator" for="stdin-chk24"><hr></label><div class="goal-conclusion"><span class="nl">?x₂</span> = bind x₂ k₂</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk25">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁, u₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ru</var><span class="hyp-type"><b>: </b><span>u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>Free f t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>m t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R Rt x₁ x₂</span></span></span><br><span><var>k₁</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; Free f u₁</span></span></span><br><span><var>k₂</var><span class="hyp-type"><b>: </b><span>t₂ -&gt; m u₂</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
Rt x₁ x₂ -&gt; R Ru (k₁ x₁) (k₂ x₂)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (bind x₁ k₁) = <span class="nl">?x₁&#39;</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> foldFree_bindFree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk26">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁, u₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ru</var><span class="hyp-type"><b>: </b><span>u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>Free f t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>m t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R Rt x₁ x₂</span></span></span><br><span><var>k₁</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; Free f u₁</span></span></span><br><span><var>k₂</var><span class="hyp-type"><b>: </b><span>t₂ -&gt; m u₂</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
Rt x₁ x₂ -&gt; R Ru (k₁ x₁) (k₂ x₂)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">propeq1 Ru
  (bind (foldFree x₁) (<span class="kr">fun</span> <span class="nv">x</span> : t₁ =&gt; foldFree (k₁ x)))
  <span class="nl">?x₂</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> RMonad_RLM; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk27">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>t₁, t₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Rt</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; t₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>u₁, u₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ru</var><span class="hyp-type"><b>: </b><span>u₁ -&gt; u₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>Free f t₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>m t₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R Rt x₁ x₂</span></span></span><br><span><var>k₁</var><span class="hyp-type"><b>: </b><span>t₁ -&gt; Free f u₁</span></span></span><br><span><var>k₂</var><span class="hyp-type"><b>: </b><span>t₂ -&gt; m u₂</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x₁</span> : t₁) (<span class="nv">x₂</span> : t₂),
Rt x₁ x₂ -&gt; R Ru (k₁ x₁) (k₂ x₂)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bind x₂ k₂ = bind x₂ k₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">Rf</span> : PropEq1 f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">RMonadFree_m</span> : RMonadFree propeq1 propeq1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk28"><span class="kn">Lemma</span> <span class="nf">RMonadFree_foldFree</span> : RMonadFree Rf R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RMonadFree Rf R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RMonadFree Rf R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2a"><span class="nb">constructor</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R Ra (free x₁) (free x₂)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R Ra (free x₁) (free x₂)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2c"><span class="nb">unfold</span> R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">propeq1 Ra (foldFree (free x₁)) (free x₂)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2d"><span class="nb">eapply</span> trans_propeq1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (free x₁) = <span class="nl">?x₁&#39;</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><label class="goal-separator" for="stdin-chk2e"><hr></label><div class="goal-conclusion">propeq1 Ra <span class="nl">?x₁&#39;</span> <span class="nl">?x₂</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="stdin-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><label class="goal-separator" for="stdin-chk2f"><hr></label><div class="goal-conclusion"><span class="nl">?x₂</span> = free x₂</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk30">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (free x₁) = <span class="nl">?x₁&#39;</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> bind_pure.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk31">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">propeq1 Ra (free x₁) <span class="nl">?x₂</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk32"><span class="nb">apply</span> RMonadFree_m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">propeq1 Ra x₁ <span class="nl">?Goal0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">eassumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk33">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f, m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonad0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonad</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
  (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
  (<span class="nv">u₁</span> : Free f a₁) 
  (<span class="nv">u₂</span> : m a₂) =&gt; propeq1 Ra (foldFree u₁) u₂</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
(a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt; Free f a₁ -&gt; m a₂ -&gt; <span class="kt">Prop</span></span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>RMonadFree_m</var><span class="hyp-type"><b>: </b><span>RMonadFree propeq1 propeq1</span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Ra</var><span class="hyp-type"><b>: </b><span>a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>x₁</var><span class="hyp-type"><b>: </b><span>f a₁</span></span></span><br><span><var>x₂</var><span class="hyp-type"><b>: </b><span>f a₂</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Rf Ra x₁ x₂</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">free x₂ = free x₂</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ISOPROOF</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk34"><span class="kn">Theorem</span> <span class="nf">from_to</span> <span class="nv">f</span> (<span class="nv">Rf</span> : PropEq1 f) <span class="nv">a</span> (<span class="nv">u</span> : Free&#39; f a)
  : RFree&#39; Rf eq u u -&gt;
    toFree&#39; (fromFree&#39; u) = u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free&#39; f a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RFree&#39; Rf eq u u -&gt; toFree&#39; (fromFree&#39; u) = u</div></blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free&#39; f a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RFree&#39; Rf eq u u -&gt; toFree&#39; (fromFree&#39; u) = u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk36"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">red</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free&#39; f a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>RFree&#39; Rf eq u u</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonadFree0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonadFree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">toFree&#39; (fromFree&#39; u) H1 = u m H0 H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk37"><span class="nb">unfold</span> toFree&#39;, fromFree&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free&#39; f a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>RFree&#39; Rf eq u u</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonadFree0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonadFree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (u (Free f) Monad_Free MonadFree_Free) =
u m H0 H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk38"><span class="nb">red</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free&#39; f a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m₁</span> <span class="nv">m₂</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) 
  (<span class="nv">H</span> : Monad m₁) 
  (<span class="nv">H0</span> : MonadFree f m₁) 
  (<span class="nv">H1</span> : Monad m₂) 
  (<span class="nv">H2</span> : MonadFree f m₂)
  (<span class="nv">Rm</span> : <span class="kr">forall</span> <span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>,
        (a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) -&gt;
        m₁ a₁ -&gt; m₂ a₂ -&gt; <span class="kt">Prop</span>),
RMonad Rm -&gt;
RMonadFree Rf Rm -&gt;
Rm a a eq (u m₁ H H0) (u m₂ H1 H2)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>ReallyLawfulMonadFree0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonadFree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (u (Free f) Monad_Free MonadFree_Free) =
u m H0 H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk39"><span class="nb">specialize</span> (H (Free f) m _ _ _ _ _ RMonad_foldFree (RMonadFree_foldFree RMonadFree_RLMF)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Rf</var><span class="hyp-type"><b>: </b><span>PropEq1 f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Free&#39; f a</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Monad m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>MonadFree f m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>PropEq1 m</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> (<span class="nv">a₁</span> <span class="nv">a₂</span> : <span class="kt">Type</span>) 
   (<span class="nv">Ra</span> : a₁ -&gt; a₂ -&gt; <span class="kt">Prop</span>) 
   (<span class="nv">u₁</span> : Free f a₁) 
   (<span class="nv">u₂</span> : m a₂) =&gt; 
 propeq1 Ra (foldFree u₁) u₂) a a eq
  (u (Free f) Monad_Free MonadFree_Free)
  (u m H0 H1)</span></span></span><br><span><var>ReallyLawfulMonadFree0</var><span class="hyp-type"><b>: </b><span>ReallyLawfulMonadFree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldFree (u (Free f) Monad_Free MonadFree_Free) =
u m H0 H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
