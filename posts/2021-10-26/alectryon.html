<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Arith Lia.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Primitive Projections</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Maximal Implicit Insertion</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Contextual Implicit</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ColistF</span> (<span class="nv">a</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : <span class="kt">Type</span>) :=
| Nil : ColistF a x
| Cons : a -&gt; x -&gt; ColistF a x
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">Colist</span> (<span class="nv">a</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  Delay { force : ColistF a (Colist a) }.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Add Printing Constructor</span> Colist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> colist_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> colist_scope <span class="kr">with</span> colist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> colist_scope.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;&#39;[&#39; &#39;]&#39;&quot;</span> := Nil : colist_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x :: xs&quot;</span> := (Cons x xs) : colist_scope.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">map</span> {<span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f</span> : a -&gt; b) (<span class="nv">xs</span> : Colist a) : Colist b := Delay
  <span class="kr">match</span> force xs <span class="kr">with</span>
  | [] =&gt; []
  | x :: xs =&gt; f x :: map f xs
  <span class="kr">end</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">nats_from</span> (<span class="nv">n</span> : nat) : Colist nat := Delay
  (n :: nats_from (S n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">nats</span> := nats_from <span class="mi">0</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Neverending_invariant</span> {<span class="nv">a</span>} (<span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">xs</span>, P xs -&gt; <span class="kr">exists</span> <span class="nv">x</span> <span class="nv">xs&#39;</span>, force xs = Cons x xs&#39; /\ P xs&#39;.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Neverending</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a) : <span class="kt">Prop</span> :=
  <span class="kr">exists</span> (<span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>),
    Neverending_invariant P /\ P xs.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk0"><span class="kn">Lemma</span> <span class="nf">unfold_Neverending</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a)
  : Neverending xs -&gt;
    <span class="kr">exists</span> <span class="nv">x</span> <span class="nv">xs&#39;</span>,
      force xs = Cons x xs&#39; /\ Neverending xs&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2"><span class="nb">intros</span> NE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3"><span class="nb">unfold</span> Neverending <span class="kr">in</span> NE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>,
  Neverending_invariant P /\ P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk4"><span class="nb">destruct</span> NE <span class="kr">as</span> [P [NE Hxs]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending_invariant P</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk5"><span class="nb">unfold</span> Neverending_invariant <span class="kr">in</span> NE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
P xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ P xs&#39;</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6"><span class="nb">apply</span> NE <span class="kr">in</span> Hxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
P xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ P xs&#39;</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a), force xs = x :: xs&#39; /\ P xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk7"><span class="nb">destruct</span> Hxs <span class="kr">as</span> [x [xs&#39; [Hxs Hxs&#39;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
P xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ P xs&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>Hxs'</var><span class="hyp-type"><b>: </b><span>P xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk8"><span class="kr">exists</span> <span class="nv">x</span>, xs&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
P xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ P xs&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>Hxs'</var><span class="hyp-type"><b>: </b><span>P xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">force xs = x :: xs&#39; /\ Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk9"><span class="nb">split</span>; [<span class="bp">assumption</span> | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
P xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ P xs&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>Hxs'</var><span class="hyp-type"><b>: </b><span>P xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chka"><span class="nb">unfold</span> Neverending.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
P xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ P xs&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>Hxs'</var><span class="hyp-type"><b>: </b><span>P xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>,
  Neverending_invariant P /\ P xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkb"><span class="kr">exists</span> <span class="nv">P</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
P xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ P xs&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>Hxs'</var><span class="hyp-type"><b>: </b><span>P xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant P /\ P xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkc"><span class="nb">split</span>; [ | <span class="bp">assumption</span> ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
P xs -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ P xs&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>Hxs'</var><span class="hyp-type"><b>: </b><span>P xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> NE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkd"><span class="kn">Lemma</span> <span class="nf">Neverending_invariant_Neverending</span> {<span class="nv">a</span>}
  : Neverending_invariant (Neverending (a := a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant Neverending</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant Neverending</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkf"><span class="nb">unfold</span> Neverending. <span class="c">(* This goal looks funny -&gt; *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant
  (<span class="kr">fun</span> <span class="nv">xs</span> : Colist a =&gt;
   <span class="kr">exists</span> <span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>,
     Neverending_invariant P /\ P xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@unfold_Neverending a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk10"><span class="kn">Lemma</span> <span class="nf">Neverending_weakest</span> {<span class="nv">a</span>} (<span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>) (<span class="nv">xs</span> : Colist a)
  : Neverending_invariant P -&gt; P xs -&gt; Neverending xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant P -&gt; P xs -&gt; Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant P -&gt; P xs -&gt; Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk12"><span class="nb">intros</span> INV H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>INV</var><span class="hyp-type"><b>: </b><span>Neverending_invariant P</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk13"><span class="nb">unfold</span> Neverending.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>INV</var><span class="hyp-type"><b>: </b><span>Neverending_invariant P</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>,
  Neverending_invariant P /\ P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk14"><span class="kr">exists</span> <span class="nv">P</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>INV</var><span class="hyp-type"><b>: </b><span>Neverending_invariant P</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant P /\ P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">injective</span> {<span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f</span> : a -&gt; b) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f x = f y -&gt; x = y.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Elimination Schemes</span>. <span class="c">(* Don&#39;t generate induction principles for us. *)</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">In</span> {<span class="nv">a</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : a) (<span class="nv">xs</span> : Colist a) : <span class="kt">Prop</span> :=
| In_split y ys : force xs = Cons y ys -&gt; x = y \/ In x ys -&gt; In x xs
.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk15"><span class="kn">Lemma</span> <span class="nf">In_ind</span> (<span class="nv">a</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : a) (<span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>)
    (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">xs</span> (<span class="nv">y</span> : a) (<span class="nv">ys</span> : Colist a),
         force xs = y :: ys -&gt; x = y \/ (In x ys /\ P ys) -&gt; P xs)
  : <span class="kr">forall</span> <span class="nv">xs</span>, In x xs -&gt; P xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">y</span> : a) (<span class="nv">ys</span> : Colist a),
force xs = y :: ys -&gt;
x = y \/ In x ys /\ P ys -&gt; P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> : Colist a, In x xs -&gt; P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">y</span> : a) (<span class="nv">ys</span> : Colist a),
force xs = y :: ys -&gt;
x = y \/ In x ys /\ P ys -&gt; P xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> : Colist a, In x xs -&gt; P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk17"><span class="kr">fix</span> SELF <span class="mi">2</span>; <span class="nb">intros</span> xs [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">y</span> : a) (<span class="nv">ys</span> : Colist a),
force xs = y :: ys -&gt;
x = y \/ In x ys /\ P ys -&gt; P xs</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a, In x xs -&gt; P xs</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>force xs = y :: ys</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x = y \/ In x ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk18"><span class="nb">eapply</span> H; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colist a -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">y</span> : a) (<span class="nv">ys</span> : Colist a),
force xs = y :: ys -&gt;
x = y \/ In x ys /\ P ys -&gt; P xs</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a, In x xs -&gt; P xs</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>force xs = y :: ys</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x = y \/ In x ys</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y \/ In x ys /\ P ys</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> H1; [ <span class="nb">left</span> | <span class="nb">right</span> ]; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk19"><span class="kn">Lemma</span> <span class="nf">not_In_Nil</span> {<span class="nv">a</span>} (<span class="nv">x</span> : a) <span class="nv">xs</span> : force xs = [] -&gt; In x xs -&gt; <span class="kt">False</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">force xs = [ ] -&gt; In x xs -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">force xs = [ ] -&gt; In x xs -&gt; <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? []; <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[<span class="kn">global</span>] <span class="kn">Hint Resolve</span> not_In_Nil : core.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Surnumerable</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a) : <span class="kt">Prop</span> :=
  <span class="kr">exists</span> <span class="nv">f</span> : nat -&gt; a,
    injective f /\ <span class="kr">forall</span> <span class="nv">i</span>, In (f i) xs.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1b"><span class="kn">Theorem</span> <span class="nf">Surnumerable_Neverending</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a)
  : Surnumerable xs -&gt; Neverending xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Surnumerable xs -&gt; Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Surnumerable xs -&gt; Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Exercise for the reader. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">splitmono</span> {<span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">f</span> : a -&gt; b) : <span class="kt">Prop</span> :=
  <span class="kr">exists</span> <span class="nv">g</span> : b -&gt; a, <span class="kr">forall</span> <span class="nv">x</span>, g (f x) = x.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">SplitSurnumerable</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a) : <span class="kt">Prop</span> :=
  <span class="kr">exists</span> (<span class="nv">f</span> : nat -&gt; a),
    splitmono f /\ <span class="kr">forall</span> <span class="nv">i</span>, In (f i) xs.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1d"><span class="kn">Theorem</span> <span class="nf">SplitSurnumerable_Neverending</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a)
  : SplitSurnumerable xs -&gt; Neverending xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplitSurnumerable xs -&gt; Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplitSurnumerable xs -&gt; Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1f"><span class="nb">intros</span> PN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>PN</var><span class="hyp-type"><b>: </b><span>SplitSurnumerable xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk20"><span class="nb">unfold</span> SplitSurnumerable <span class="kr">in</span> PN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>PN</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">f</span> : nat -&gt; a,
  splitmono f /\ (<span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk21"><span class="nb">destruct</span> PN <span class="kr">as</span> (f &amp; Hf &amp; Hincl).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk22"><span class="nb">unfold</span> Neverending.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>,
  Neverending_invariant P /\ P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Here is the never-ending invariant. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk23"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">xs</span> =&gt; <span class="kr">exists</span> <span class="nv">n</span>, <span class="kr">forall</span> <span class="nv">i</span>, n &lt;= i -&gt; In (f i) xs).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant
  (<span class="kr">fun</span> <span class="nv">xs</span> : Colist a =&gt;
   <span class="kr">exists</span> <span class="nv">n</span> : nat,
     <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs) /\
(<span class="kr">exists</span> <span class="nv">n</span> : nat, <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk24"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant
  (<span class="kr">fun</span> <span class="nv">xs</span> : Colist a =&gt;
   <span class="kr">exists</span> <span class="nv">n</span> : nat,
     <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk25" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br></div><label class="goal-separator" for="stdin-chk25"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk26">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant
  (<span class="kr">fun</span> <span class="nv">xs</span> : Colist a =&gt;
   <span class="kr">exists</span> <span class="nv">n</span> : nat,
     <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk27"><span class="nb">unfold</span> Neverending_invariant.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
(<span class="kr">exists</span> <span class="nv">n</span> : nat, <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs) -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat,
     <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk28"><span class="nb">intros</span> xs_ [n Hn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs_ = x :: xs&#39; /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat,
     <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk29"><span class="nb">destruct</span> (force xs_) <span class="kr">as</span> [ | x xs&#39;] <span class="nb">eqn</span>:Hforce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = [ ]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  [ ] = x :: xs&#39; /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat,
     <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br></div><label class="goal-separator" for="stdin-chk2a"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x0</span> : a) (<span class="nv">xs&#39;0</span> : Colist a),
  x :: xs&#39; = x0 :: xs&#39;0 /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat,
     <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs&#39;0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = [ ]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  [ ] = x :: xs&#39; /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat,
     <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2c"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = [ ]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto using</span> not_In_Nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x0</span> : a) (<span class="nv">xs&#39;0</span> : Colist a),
  x :: xs&#39; = x0 :: xs&#39;0 /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat,
     <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs&#39;0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2e"><span class="kr">exists</span> <span class="nv">x</span>, xs&#39;; <span class="nb">split</span>; [ <span class="nb">auto</span> | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2f"><span class="nb">destruct</span> Hf <span class="kr">as</span> [g Hf].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk30"><span class="kr">exists</span> (<span class="nv">max</span> <span class="nv">n</span> (S (g x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : nat,
Init.Nat.max n (S (g x)) &lt;= i -&gt; In (f i) xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk31"><span class="nb">intros</span> i Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs_</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g x)) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (f i) xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk32"><span class="nb">specialize</span> (Hn i (Nat.max_lub_l _ _ _ Hi)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>In (f i) xs_</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g x)) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (f i) xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk33"><span class="nb">destruct</span> Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>ys</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs_ = y :: ys</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>f i = y \/ In (f i) ys</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hforce</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g x)) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (f i) xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk34"><span class="nb">rewrite</span> H <span class="kr">in</span> Hforce; <span class="nb">inversion</span> Hforce; <span class="nb">subst</span>; <span class="nb">clear</span> Hforce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>f i = x \/ In (f i) xs&#39;</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g x)) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (f i) xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk35"><span class="nb">destruct</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>f i = x</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g x)) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (f i) xs&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In (f i) xs&#39;</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g x)) &lt;= i</span></span></span><br></div><label class="goal-separator" for="stdin-chk36"><hr></label><div class="goal-conclusion">In (f i) xs&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk37">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>f i = x</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g x)) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (f i) xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk38"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>f i = x</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g x)) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk39"><span class="nb">rewrite</span> &lt;- H0 <span class="kr">in</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>f i = x</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g (f i))) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3a"><span class="nb">rewrite</span> Hf <span class="kr">in</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>f i = x</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S i) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>a -&gt; nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : nat, g (f x) = x</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs_ = x :: xs&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In (f i) xs&#39;</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Init.Nat.max n (S (g x)) &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (f i) xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, <span class="kr">forall</span> <span class="nv">i</span> : nat, n &lt;= i -&gt; In (f i) xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3d"><span class="kr">exists</span> <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>splitmono f</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : nat, <span class="mi">0</span> &lt;= i -&gt; In (f i) xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">RColistF</span> {<span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">r</span> : a -&gt; b -&gt; <span class="kt">Prop</span>) <span class="nv">xa</span> <span class="nv">xb</span> (<span class="nv">rx</span> : xa -&gt; xb -&gt; <span class="kt">Prop</span>)
  : ColistF a xa -&gt; ColistF b xb -&gt; <span class="kt">Prop</span> :=
| RNil : RColistF r rx [] []
| RCons x xs y ys : r x y -&gt; rx xs ys -&gt; RColistF r rx (Cons x xs) (Cons y ys)
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">RColist</span> {<span class="nv">a</span> <span class="nv">b</span>} (<span class="nv">r</span> : a -&gt; b -&gt; <span class="kt">Prop</span>) (<span class="nv">xs</span> : Colist a) (<span class="nv">ys</span> : Colist b) : <span class="kt">Prop</span> :=
  RDelay { Rforce : RColistF r (RColist r) (force xs) (force ys) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x == y&quot;</span> := (RColist eq x y) (<span class="kn">at level</span> <span class="mi">70</span>) : colist_scope.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Enumerable_by</span> {<span class="nv">a</span>} (<span class="nv">f</span> : nat -&gt; a) (<span class="nv">xs</span> : Colist a) : <span class="kt">Prop</span> :=
  xs == map f nats.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Enumerable</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a) : <span class="kt">Prop</span> :=
  <span class="kr">exists</span> <span class="nv">f</span>, Enumerable_by f xs.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">index_def</span> {<span class="nv">a</span>} (<span class="nv">def</span> : a) (<span class="nv">xs</span> : Colist a) (<span class="nv">i</span> : nat) : a :=
  <span class="kr">match</span> force xs, i <span class="kr">with</span>
  | Cons x _, O =&gt; x
  | Cons _ xs, S i =&gt; index_def def xs i
  | Nil, _ =&gt; def
  <span class="kr">end</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3e"><span class="kn">Definition</span> <span class="nf">head_NE</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs) : a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk40"><span class="nb">destruct</span> (force xs) <span class="kr">as</span> [ | x xs&#39; ] <span class="nb">eqn</span>:Hxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = [ ]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br></div><label class="goal-separator" for="stdin-chk41"><hr></label><div class="goal-conclusion">a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk42">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = [ ]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk43"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = [ ]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk44"><span class="nb">apply</span> unfold_Neverending <span class="kr">in</span> NE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = [ ]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk45"><span class="nb">destruct</span> NE <span class="kr">as</span> [? [? []]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>force xs = x :: x0</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Neverending x0</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = [ ]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">index</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs) (<span class="nv">i</span> : nat) : a :=
  index_def (head_NE NE) xs i.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk47"><span class="kn">Lemma</span> <span class="nf">index_def_Neverending</span> {<span class="nv">a</span>} (<span class="nv">def</span> <span class="nv">def&#39;</span> : a) (<span class="nv">xs</span> : Colist a) (<span class="nv">i</span> : nat)
  : Neverending xs -&gt; index_def def xs i = index_def def&#39; xs i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs -&gt;
index_def def xs i = index_def def&#39; xs i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs -&gt;
index_def def xs i = index_def def&#39; xs i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk49"><span class="nb">revert</span> xs; <span class="nb">induction</span> i; <span class="nb">intros</span> * NE; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def
| x :: _ =&gt; x
<span class="kr">end</span> =
<span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def&#39;
| x :: _ =&gt; x
<span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
Neverending xs -&gt;
index_def def xs i = index_def def&#39; xs i</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><label class="goal-separator" for="stdin-chk4a"><hr></label><div class="goal-conclusion"><span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def
| _ :: xs =&gt; index_def def xs i
<span class="kr">end</span> =
<span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def&#39;
| _ :: xs =&gt; index_def def&#39; xs i
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk4b"><span class="kp">all</span>: <span class="nb">apply</span> unfold_Neverending <span class="kr">in</span> NE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def
| x :: _ =&gt; x
<span class="kr">end</span> =
<span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def&#39;
| x :: _ =&gt; x
<span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
Neverending xs -&gt;
index_def def xs i = index_def def&#39; xs i</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</span></span></span><br></div><label class="goal-separator" for="stdin-chk4c"><hr></label><div class="goal-conclusion"><span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def
| _ :: xs =&gt; index_def def xs i
<span class="kr">end</span> =
<span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def&#39;
| _ :: xs =&gt; index_def def&#39; xs i
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk4d"><span class="kp">all</span>: <span class="nb">destruct</span> NE <span class="kr">as</span> [x [xs&#39; [Hxs NE]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def
| x :: _ =&gt; x
<span class="kr">end</span> =
<span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def&#39;
| x :: _ =&gt; x
<span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
Neverending xs -&gt;
index_def def xs i = index_def def&#39; xs i</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><label class="goal-separator" for="stdin-chk4e"><hr></label><div class="goal-conclusion"><span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def
| _ :: xs =&gt; index_def def xs i
<span class="kr">end</span> =
<span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; def&#39;
| _ :: xs =&gt; index_def def&#39; xs i
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk4f"><span class="kp">all</span>: <span class="nb">rewrite</span> Hxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>def, def'</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
Neverending xs -&gt;
index_def def xs i = index_def def&#39; xs i</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><label class="goal-separator" for="stdin-chk50"><hr></label><div class="goal-conclusion">index_def def xs&#39; i = index_def def&#39; xs&#39; i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk51"><span class="kn">Lemma</span> <span class="nf">Neverending_Enumerable_</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
    (<span class="nv">f</span> : nat -&gt; a) (<span class="nv">n</span> : nat)
  : (<span class="kr">forall</span> <span class="nv">i</span>, f (n+i) = index NE i) -&gt;
    xs == map f (nats_from n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk53"><span class="nb">revert</span> xs NE n; <span class="kr">cofix</span> SELF; <span class="nb">intros</span> * Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs == map f (nats_from n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk54"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RColistF eq (RColist eq) 
  (force xs) (force (map f (nats_from n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk55"><span class="nb">assert</span> (NE&#39; := NE).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RColistF eq (RColist eq) 
  (force xs) (force (map f (nats_from n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk56"><span class="nb">apply</span> unfold_Neverending <span class="kr">in</span> NE&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\ Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RColistF eq (RColist eq) 
  (force xs) (force (map f (nats_from n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk57"><span class="nb">destruct</span> NE&#39; <span class="kr">as</span> [x [xs&#39; [Hxs NE&#39;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RColistF eq (RColist eq) 
  (force xs) (force (map f (nats_from n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk58"><span class="nb">rewrite</span> Hxs; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RColistF eq (RColist eq) 
  (x :: xs&#39;) (f n :: map f (nats_from (S n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk59"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = f n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><label class="goal-separator" for="stdin-chk5a"><hr></label><div class="goal-conclusion">xs&#39; == map f (nats_from (S n))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk5b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = f n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk5c"><span class="nb">specialize</span> (Hf <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>f (n + <span class="mi">0</span>) = index NE <span class="mi">0</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = f n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk5d"><span class="nb">cbn</span> <span class="kr">in</span> Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>f (n + <span class="mi">0</span>) =
<span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; head_NE NE
| x :: _ =&gt; x
<span class="kr">end</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = f n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk5e"><span class="nb">rewrite</span> Nat.add_0_r, Hxs <span class="kr">in</span> Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>f n = x</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = f n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>SELF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  (<span class="nv">n</span> : nat),
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i) -&gt;
xs == map f (nats_from n)</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs&#39; == map f (nats_from (S n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk60"><span class="nb">apply</span> SELF <span class="kr">with</span> (NE := NE&#39;); <span class="nb">clear</span> SELF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : nat, f (S n + i) = index NE&#39; i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk61"><span class="nb">intros</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f (n + i) = index NE i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (S n + i) = index NE&#39; i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk62"><span class="nb">specialize</span> (Hf (S i)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>f (n + S i) = index NE (S i)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (S n + i) = index NE&#39; i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk63"><span class="nb">cbn</span> <span class="kr">in</span> Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>f (n + S i) =
<span class="kr">match</span> force xs <span class="kr">with</span>
| [ ] =&gt; head_NE NE
| _ :: xs0 =&gt; index_def (head_NE NE) xs0 i
<span class="kr">end</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (S n + i) = index NE&#39; i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk64"><span class="nb">rewrite</span> Nat.add_succ_r, Hxs <span class="kr">in</span> Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>f (S (n + i)) = index_def (head_NE NE) xs&#39; i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (S n + i) = index NE&#39; i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk65"><span class="nb">cbn</span>; <span class="nb">rewrite</span> Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>f (S (n + i)) = index_def (head_NE NE) xs&#39; i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">index_def (head_NE NE) xs&#39; i = index NE&#39; i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk66"><span class="nb">unfold</span> index.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>f (S (n + i)) = index_def (head_NE NE) xs&#39; i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">index_def (head_NE NE) xs&#39; i =
index_def (head_NE NE&#39;) xs&#39; i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk67"><span class="nb">apply</span> index_def_Neverending.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>f (S (n + i)) = index_def (head_NE NE) xs&#39; i</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>force xs = x :: xs&#39;</span></span></span><br><span><var>NE'</var><span class="hyp-type"><b>: </b><span>Neverending xs&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk68"><span class="kn">Theorem</span> <span class="nf">Neverending_Enumerable_by</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a) (<span class="nv">NE</span> : Neverending xs)
  : Enumerable_by (index NE) xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Enumerable_by (index NE) xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Enumerable_by (index NE) xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6a"><span class="nb">unfold</span> Enumerable_by, nats.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs == map (index NE) (nats_from <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6b"><span class="nb">apply</span> Neverending_Enumerable_ <span class="kr">with</span> (NE := NE) (n := <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>NE</var><span class="hyp-type"><b>: </b><span>Neverending xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : nat, index NE (<span class="mi">0</span> + i) = index NE i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6c"><span class="kn">Corollary</span> <span class="nf">Neverending_Enumerable</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a)
  : Neverending xs -&gt; Enumerable xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs -&gt; Enumerable xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs -&gt; Enumerable xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> NE; <span class="nb">eexists</span>; <span class="nb">apply</span> (Neverending_Enumerable_by (NE := NE)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6e"><span class="kn">Theorem</span> <span class="nf">Enumerable_Neverending</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : Colist a)
  : Enumerable xs -&gt; Neverending xs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Enumerable xs -&gt; Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Enumerable xs -&gt; Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk70"><span class="nb">unfold</span> Enumerable, Enumerable_by.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">f</span> : nat -&gt; a, xs == map f nats) -&gt;
Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk71"><span class="nb">intros</span> [f EB].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk72"><span class="nb">unfold</span> Neverending.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>,
  Neverending_invariant P /\ P xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk73"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">xs</span> =&gt; <span class="kr">exists</span> <span class="nv">n</span>, xs == map f (nats_from n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant
  (<span class="kr">fun</span> <span class="nv">xs</span> : Colist a =&gt;
   <span class="kr">exists</span> <span class="nv">n</span> : nat, xs == map f (nats_from n)) /\
(<span class="kr">exists</span> <span class="nv">n</span> : nat, xs == map f (nats_from n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk74"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant
  (<span class="kr">fun</span> <span class="nv">xs</span> : Colist a =&gt;
   <span class="kr">exists</span> <span class="nv">n</span> : nat, xs == map f (nats_from n))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br></div><label class="goal-separator" for="stdin-chk75"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, xs == map f (nats_from n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk76">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neverending_invariant
  (<span class="kr">fun</span> <span class="nv">xs</span> : Colist a =&gt;
   <span class="kr">exists</span> <span class="nv">n</span> : nat, xs == map f (nats_from n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk77"><span class="nb">unfold</span> Neverending_invariant.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> : Colist a,
(<span class="kr">exists</span> <span class="nv">n</span> : nat, xs == map f (nats_from n)) -&gt;
<span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs = x :: xs&#39; /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat, xs&#39; == map f (nats_from n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk78"><span class="nb">intros</span> xs_ [n EB_].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>EB_</var><span class="hyp-type"><b>: </b><span>xs_ == map f (nats_from n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs_ = x :: xs&#39; /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat, xs&#39; == map f (nats_from n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk79"><span class="nb">destruct</span> EB_ <span class="kr">as</span> [EB_].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>EB_</var><span class="hyp-type"><b>: </b><span>RColistF eq (RColist eq) (force xs_) (force (map f (nats_from n)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs_ = x :: xs&#39; /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat, xs&#39; == map f (nats_from n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk7a"><span class="nb">cbn</span> <span class="kr">in</span> EB_.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>EB_</var><span class="hyp-type"><b>: </b><span>RColistF eq (RColist eq) (force xs_) (f n :: map f (nats_from (S n)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  force xs_ = x :: xs&#39; /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat, xs&#39; == map f (nats_from n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk7b"><span class="nb">inversion</span> EB_; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>EB_</var><span class="hyp-type"><b>: </b><span>RColistF eq (RColist eq) (force xs_) (f n :: map f (nats_from (S n)))</span></span></span><br><span><var>xs0</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>xs0 == map f (nats_from (S n))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f n :: xs0 = force xs_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> (<span class="nv">x</span> : a) (<span class="nv">xs&#39;</span> : Colist a),
  f n :: xs0 = x :: xs&#39; /\
  (<span class="kr">exists</span> <span class="nv">n</span> : nat, xs&#39; == map f (nats_from n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk7c"><span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">n</span>), xs0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>EB_</var><span class="hyp-type"><b>: </b><span>RColistF eq (RColist eq) (force xs_) (f n :: map f (nats_from (S n)))</span></span></span><br><span><var>xs0</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>xs0 == map f (nats_from (S n))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f n :: xs0 = force xs_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f n :: xs0 = f n :: xs0 /\
(<span class="kr">exists</span> <span class="nv">n</span> : nat, xs0 == map f (nats_from n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk7d"><span class="nb">split</span>; [ <span class="nb">auto</span> | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>EB_</var><span class="hyp-type"><b>: </b><span>RColistF eq (RColist eq) (force xs_) (f n :: map f (nats_from (S n)))</span></span></span><br><span><var>xs0</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>xs0 == map f (nats_from (S n))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f n :: xs0 = force xs_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, xs0 == map f (nats_from n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk7e"><span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">n</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br><span><var>xs_</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>EB_</var><span class="hyp-type"><b>: </b><span>RColistF eq (RColist eq) (force xs_) (f n :: map f (nats_from (S n)))</span></span></span><br><span><var>xs0</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>xs0 == map f (nats_from (S n))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f n :: xs0 = force xs_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs0 == map f (nats_from (S n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>Colist a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; a</span></span></span><br><span><var>EB</var><span class="hyp-type"><b>: </b><span>xs == map f nats</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">n</span> : nat, xs == map f (nats_from n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">exists</span> <span class="mi">0</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk80"><span class="kn">Print</span> SplitSurnumerable.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">SplitSurnumerable = 
<span class="kr">fun</span> (<span class="nv">a</span> : <span class="kt">Type</span>) (<span class="nv">xs</span> : Colist a) =&gt;
<span class="kr">exists</span> <span class="nv">f</span> : nat -&gt; a,
  splitmono f /\ (<span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs)
     : <span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, Colist a -&gt; <span class="kt">Prop</span>

<span class="kn">Arguments</span> SplitSurnumerable {a}%type_scope xs</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(*      ⇓      *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk81"><span class="kn">Print</span> Surnumerable.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Surnumerable = 
<span class="kr">fun</span> (<span class="nv">a</span> : <span class="kt">Type</span>) (<span class="nv">xs</span> : Colist a) =&gt;
<span class="kr">exists</span> <span class="nv">f</span> : nat -&gt; a,
  injective f /\ (<span class="kr">forall</span> <span class="nv">i</span> : nat, In (f i) xs)
     : <span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, Colist a -&gt; <span class="kt">Prop</span>

<span class="kn">Arguments</span> Surnumerable {a}%type_scope xs</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(*      ⇓      *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk82"><span class="kn">Print</span> Neverending.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Neverending = 
<span class="kr">fun</span> (<span class="nv">a</span> : <span class="kt">Type</span>) (<span class="nv">xs</span> : Colist a) =&gt;
<span class="kr">exists</span> <span class="nv">P</span> : Colist a -&gt; <span class="kt">Prop</span>,
  Neverending_invariant P /\ P xs
     : <span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, Colist a -&gt; <span class="kt">Prop</span>

<span class="kn">Arguments</span> Neverending {a}%type_scope xs</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(*      ⇕      *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk83"><span class="kn">Print</span> Enumerable.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Enumerable = 
<span class="kr">fun</span> (<span class="nv">a</span> : <span class="kt">Type</span>) (<span class="nv">xs</span> : Colist a) =&gt;
<span class="kr">exists</span> <span class="nv">f</span> : nat -&gt; a, Enumerable_by f xs
     : <span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, Colist a -&gt; <span class="kt">Prop</span>

<span class="kn">Arguments</span> Enumerable {a}%type_scope xs</blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
